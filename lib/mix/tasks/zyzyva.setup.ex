defmodule Mix.Tasks.Zyzyva.Setup do
  @moduledoc """
  Generates ZyzyvaTelemetry integration code for Phoenix applications.

  Usage:
      mix zyzyva.setup

  This task will:
  - Generate a test helper for health endpoint testing
  - Show instructions for integrating monitoring into your app
  - Create example configuration
  """

  use Mix.Task

  @shortdoc "Sets up ZyzyvaTelemetry monitoring in a Phoenix app"

  def run(_args) do
    app_name = Mix.Project.config()[:app]
    web_module = get_web_module(app_name)

    Mix.shell().info("Setting up ZyzyvaTelemetry for #{app_name}...")

    # Generate test helper
    generate_test_helper(web_module)

    # Add test configuration
    add_test_config(app_name)

    # Show integration instructions
    show_integration_instructions(app_name, web_module)

    Mix.shell().info("\n✅ ZyzyvaTelemetry setup complete!")
  end

  defp get_web_module(app_name) do
    # Convert app_name to CamelCase for module name
    app_name
    |> to_string()
    |> String.split("_")
    |> Enum.map(&String.capitalize/1)
    |> Enum.join("")
    |> then(&"#{&1}Web")
  end

  defp generate_test_helper(web_module) do
    test_helper_path = "test/support/health_endpoint_test_helper.ex"

    content = """
    defmodule #{web_module}.HealthEndpointTestHelper do
      @moduledoc \"\"\"
      Test helper for testing ZyzyvaTelemetry health endpoints.
      Generated by mix zyzyva.setup
      \"\"\"
      
      import ExUnit.Assertions
      
      @doc \"\"\"
      Tests a health endpoint to ensure it returns proper telemetry data.
      
      ## Options
        * `:service_name` - Expected service name (optional)
        * `:required_fields` - List of fields that must be present (defaults to standard fields)
      \"\"\"
      def assert_health_endpoint(conn, opts \\\\ []) do
        # Should return 200 OK or 503 for critical status
        assert conn.status in [200, 503]
        
        # Parse the JSON response
        body = Phoenix.json_library().decode!(conn.resp_body)
        
        # Verify standard fields
        assert body["status"] in ["healthy", "degraded", "critical", "unknown"]
        assert body["service"]
        assert body["timestamp"]
        
        # Check optional service name
        if service_name = opts[:service_name] do
          assert body["service"] == service_name
        end
        
        # Check telemetry-provided fields
        required_fields = opts[:required_fields] || ["memory", "processes", "database_connected"]
        
        for field <- required_fields do
          assert Map.has_key?(body, field), "Missing required field: \#{field}"
        end
        
        # Verify memory structure if present
        if body["memory"] do
          assert body["memory"]["mb"], "Memory should have 'mb' field"
          assert body["memory"]["status"] in ["ok", "warning", "critical"]
        end
        
        # Verify processes structure if present
        if body["processes"] do
          assert body["processes"]["count"], "Processes should have 'count' field"
          assert body["processes"]["status"] in ["ok", "warning", "critical"]
        end
        
        body
      end
      
      @doc \"\"\"
      Asserts that monitoring has been properly initialized for the app.
      \"\"\"
      def assert_monitoring_initialized do
        case ZyzyvaTelemetry.AppMonitoring.get_health_status() do
          {:ok, health_data} ->
            assert health_data[:status] in [:healthy, :degraded, :critical, :unknown]
            assert health_data[:memory]
            assert health_data[:processes]
            health_data
            
          {:error, reason} ->
            flunk("Monitoring not initialized: \#{inspect(reason)}")
        end
      end
    end
    """

    if File.exists?(test_helper_path) do
      Mix.shell().info("⚠️  Test helper already exists at #{test_helper_path}")
    else
      ensure_directory_exists(Path.dirname(test_helper_path))
      File.write!(test_helper_path, content)
      Mix.shell().info("✅ Created test helper at #{test_helper_path}")
    end
  end

  defp show_integration_instructions(app_name, web_module) do
    app_module = String.replace(web_module, "Web", "")

    Mix.shell().info("""

    ================================================================================
    INTEGRATION INSTRUCTIONS
    ================================================================================

    1. Add monitoring to your supervision tree in lib/#{app_name}/application.ex:

       def start(_type, _args) do
         children = [
           # ... your existing children
           {ZyzyvaTelemetry.MonitoringSupervisor,
            service_name: "#{app_name}",
            repo: #{app_module}.Repo,  # Optional: your Ecto repo
            broadway_pipelines: [  # Optional: Broadway pipelines to monitor
              # #{app_module}.MyPipeline.Broadway
            ]}
         ]
         
         opts = [strategy: :one_for_one, name: #{app_module}.Supervisor]
         Supervisor.start_link(children, opts)
       end

    2. Add correlation tracking to your browser pipeline:

       pipeline :browser do
         # ... existing plugs
         plug ZyzyvaTelemetry.Plugs.CorrelationTracker
       end

    3. Add health endpoint to lib/#{app_name}_web/router.ex:

       # Health endpoint (with correlation tracking)
       scope "/" do
         pipe_through :browser  # Or :api if you prefer JSON-only
         get "/health", ZyzyvaTelemetry.HealthController, :index
       end

    4. Create a test for your health endpoint:

       # test/#{app_name}_web/controllers/health_controller_test.exs
       defmodule #{web_module}.HealthControllerTest do
         use #{web_module}.ConnCase
         import #{web_module}.HealthEndpointTestHelper
         
         test "GET /health returns telemetry data", %{conn: conn} do
           conn = get(conn, "/health")
           body = assert_health_endpoint(conn,
             service_name: "#{app_name}"
           )
         end
         
         test "monitoring is properly initialized" do
           assert_monitoring_initialized()
         end
       end

    5. Configuration (optional):

       # config/config.exs or runtime.exs
       config :#{app_name},
         db_path: "/var/lib/monitoring/events.db"  # Default path

    ================================================================================
    """)
  end

  defp ensure_directory_exists(path) do
    unless File.exists?(path) do
      File.mkdir_p!(path)
    end
  end

  defp add_test_config(app_name) do
    test_config_path = "config/test.exs"

    if File.exists?(test_config_path) do
      config_to_add = """

      # Use a temporary monitoring database for tests
      config :#{app_name},
        db_path: "/tmp/monitoring_test/events.db"
      """

      # Read the existing config
      existing_config = File.read!(test_config_path)

      # Check if the config is already present
      if String.contains?(existing_config, "db_path") do
        Mix.shell().info("⚠️  Test config already contains db_path")
      else
        # Append the config to the file
        updated_config = existing_config <> config_to_add
        File.write!(test_config_path, updated_config)
        Mix.shell().info("✅ Added test configuration to #{test_config_path}")
      end
    else
      Mix.shell().info("⚠️  Test config file not found at #{test_config_path}")
    end
  end
end
